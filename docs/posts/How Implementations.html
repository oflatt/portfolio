<div><h1 style="width:8%;font-size:14px;color:rgb(100,100,100);display:inline-block;position:fixed;top:0px;right:0;cursor:default;visibility:hidden" onmouseenter="texthover(this)" onmouseout="textoff(this)" class="navtext">How Implementations</h1><div style="margin-bottom:10px;padding-bottom:10px;background-color:#B4E4E7;margin-left:2%;margin-right:0;display:inline-block" class="post"><center><div style="text-align:left;color:black;width:95%;padding-top:5px;"><h2 style="margin-bottom:0px;font-size:22px">How Implementations of the Persistent Data Type HAMT with Varying Node Sizes Compare
in Performance When Implemented in Python</h2></div><div style="color:#5A5A5A;width:95%"><div style="float:left"><h3 style="margin-top: 0px;margin-bottom:0px;padding-top:10px">2017</h3></div><div style="float:right"><h3 style="margin-top: 0px;margin-bottom:0px;padding-top:10px"></h3></div></div><div style="text-indent:2px;width:95%;overflow:auto;text-align:justify;margin-top: 0px;margin-bottom:0px;padding-top:10px">Source: <a href="hamt python.pdf" style="margin-top:0px" target="_blank">hamt python.pdf</a></div><div style="margin-bottom:10px;padding-top:10px"></div><div style="text-indent:2px;width:95%;overflow:auto;text-align:justify;margin-top: 0px;margin-bottom:0px;padding-top:10px;line-height:20px">Abstract:</div><div style="text-indent:2px;width:95%;overflow:auto;text-align:justify;line-height:20px">Researchers recently implemented the HAMT (Hash Array Mapped Trie) in many programming languages and
optimized it for performance and memory efficiency, replacing traditional hash tables in many cases. The HAMT has
many possible implementation differences that can have significant effects on its performance, such as separation
of data types, bitmap compression, and node size. The purpose of this investigation is to explore how the size of
the nodes in the data structure Hash Array Mapped Trie affect the performance of the search and insert functions on
it. To investigate this, I implemented the HAMT data structure in Python and tested it for insert and search times
with varying node sizes using the PyPy Python interpreter.  I initially hypothesize that as node size increases,
speeds for both insert and search increase, but that the greater node size increases memory overhead, making the
middle node size the most effective. My test results refute both of these claims. HAMT implementations in Python
with a node size of 32 perform best on insert and search tests and memory use decreases as node size increases.
I conclude that HAMT implementations that have bitmap compression with a node size of 32 are optimal when written
in Python.</div><dev style="color:#B4E4E7">_</dev></center></div></div>